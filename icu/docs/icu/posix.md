# 从 C 或 POSIX 迁移

## 从标准 C 和 POSIX API 迁移

ISO C 和 POSIX 标准定义了很多用于字符串处理和国际化的 C API，但它们对 Unicode 的支持并不是很好，因为它们在 Unicode 或 ISO 10646 之前就被开发出来了，并且 POSIX 在国际化的其他方面也存在问题。

本章讨论了 C 或 POSIX 的 API 和它们的问题，并给出用于替代的 ICU API。

> :point_right: **注意**：我们使用术语“POSIX”来指代 POSIX.1 标准（IEEE Std 1003.1），它定义了与字符串处理和国际化相关的系统接口和头文件。POSIX.1 是 XPG3、XPG4、*单一 UNIX 规范* 和其他标准的子集，不过它们的差集不在本章讨论范围内。

> :construction: 本章未完成——未来会讨论更多 POSIX API。

## 字符串和字符

### 字符集和编码

#### ISO C

ISO C 标准提供了两个基本字符类型（ `char` `wchar_t` ），并定义了两种对应的字符串。标准允许这两种字符串使用任意的编码和字符，当没有能在任何地方正常工作的字符集时，这是有必要的。

对于可移植的 C 程序，字符和字符串是不透明的：也就是说，一个程序不能假设任何特定字符被任何特定的编码所表示。程序使用标准库函数处理字符和字符串，只有小型字符集——通常是 ASCII 中可用的图形字符集——可以被可靠地访问。

#### 存在的问题

1. 每个平台都使用许多不同的编码，这使得多个程序和库很难处理相同的文本。
2. 程序经常需要知道特定字符串的编码。例如，解析文件名的代码需要知道路径分隔符如何被编码。一般来说这没什么问题，因为文件名一般使用 ASCII 字符，但任何使用非 ASCII 字符的文件名都会带来平台依赖性。如果不了解字符集、字符串编码和其他详细功能，就不可能进行复杂的文本处理。
3. C 或 POSIX 标准提供的字符串处理函数的数量非常少，很多函数都不能在非常规情况下工作。
4. 虽然在现代编译器中， `char` 类型的大小都是 8 位的，并且常见的编码都有相当详细的文档，但 `wchar_t` 的大小根据编译器的不同在 8 或 16 或 32 位之间变化，并且它使用的编码只有少数有文档。
5. 参见 [Unicode 需要多大的 `wchar_t`？](http://icu-project.org/docs/papers/unicode_wchar_t.html)
6. 基于此模型的程序必须针对每个平台重新编译。通常，必须针对每种受支持的语言或语言系列重新编译它。
7. ISO C 标准基本上要求，根据其标准函数的定义，用于存储大型字符集中单个字符的数据类型应为 `wchar_t` 。这导致了 C 标准库的实现使用 Unicode 编码，这些实现要么限制单字符函数只能使用 Unicode 的一部分，要么与大多数支持 Unicode 的软件的互操作性降低。


#### ICU

ICU 总是处理 Unicode 文本。Unicode 涵盖了所有语言，除了提供了许多标准或推荐的算法以及大量有用的字符属性数据之外，还允许安全地硬编码字符代码。请参阅关于 [Unicode 基础知识](unicode) 和 [字符串](../strings/) 以及其他章节。

ICU 使用 UTF-16 编码，使其能与大部分支持 Unicode 的软件具有完全可互操作性，请参见 [用 UTF-16 进行处理](http://www.unicode.org/notes/tn12/)。尤其在使用 ICU4J 的情况下是很自然的，因为 Java 语言和 JDK 都使用 UTF-16 编码。

ICU 能够直接访问所有的 [Unicode 属性](../strings/properties)，这些属性提供了比 [C / POSIX 字符类别](https://htmlpreview.github.io/?https://github.com/unicode-org/icu-docs/blob/main/design/posix_classes.html) 更细粒度的字符分类。

在 C / C++ 源代码中的字符字面量和字符串字面量中，ICU 只使用“不变的”字符，这些字符构成了 ASCII 字符集的一个子集，并且在所有系统上几乎总是使用相同的字节值进行编码。有关“不变的”字符，请参阅 [`utypes.h`](https://github.com/unicode-org/icu/blob/main/icu4c/source/common/unicode/utypes.h) 。

通过使用 Unicode、许多 Unicode 标准算法的实现以及它的跨平台性，ICU 提供了持续的、可移植和可靠的文本处理。

### 大小写变换

#### ISO C

The standard C functions `tolower()`, `toupper()`, etc. take and return one character code each.
C 的 `tolower()` `toupper()` 等函数的参数和返回值都是一个字符。

#### 存在的问题

1. 德语字符“ß”（清 S）的大写是两个字符“SS”，用不了。
2. 希腊语字母“Σ”（大写 Sigma）的小写是 σ，但如果它位于单字末尾，则写作 ς（又称 Final Sigma），也就是说，它是上下文相关的。
3. 不适用于立陶宛语和突厥语系，某些情况下要移除字符顶上的点，这也是上下文相关的
4. 类似的案例还有很多。
5. 没有用于转换标题字符串的标准函数。
6. 没有用于大小写折叠字符串的标准函数。（大小写折叠用于不区分大小写的比较；C 或 POSIX 提供了直接进行不区分大小写的字符串对比较的函数。）

#### ICU

大小写变换操作的参数和返回值都是字符串，以支持长度更改和上下文依赖性。Unicode 提供用于正确进行大小写变换的算法和数据，而 ICU 提供 API。（请参阅各种字符串函数和转换或转写的 API 参考。）

### 字符类别

#### ISO C

标准 C 函数 `isalpha()` `isdigit()` 等接受一个字符作为参数，如果给定字符属于当前区域设置对应的类别，则返回 `true` ，否则返回 `false` 。

#### 存在的问题

1. 字符类别与区域设置相关。
2. 按区域设置和平台的不同，相同的字符可能有不同的字符类别。
3. POSIX 字符类别很少，并且定义不明确。例如：有一个用于{标点符号:Punctuation}的类别，但没有用于{符号:Symbol}的类别。
5. 例如，“$”可以属于或不属于 punct 类，这取决于区域设置。
5. 标准允许最多两组十进制数：“可移植字符集”的数字（即 ASCII 字符集中的数字）和另一组。某些实现值识别 `isdigit()` 的 ASCII 数字字符。但是，像 Unicode 这种多语言字符集中有许多组十进制数字。
6. POSIX 标准假定每个区域设置定义文件都包含所有相关字符的字符类别数据。由于许多区域设置使用重叠的字符集，这可能导致大量的重复。为了提高效率，许多 UTF-8 区域设置定义只为很少的字符定义字符类别，而不是给整个 Unicode 字符集定义。例如，一些 `de_DE.utf-8` 区域设置只定义德语使用的字符——换句话说，只为可表示的 Unicode 字符集的一个小子集定义。使用这样的实现方式无法处理超出这个子集范围的文本。
7. 有关 Unicode 上下文中 POSIX 字符类别问题的更多信息，请参阅 [附录 C：Unicode 技术标准 #18 中的兼容性属性：Unicode 正则表达式](http://www.unicode.org/reports/tr18/#Compatibility_Properties) 和 Unicode 邮件列表。另请参阅有关 [C/POSIX 字符类别](https://htmlpreview.github.io/?https://github.com/unicode-org/icu-docs/blob/main/design/posix_classes.html) 的 ICU 设计文档。

#### ICU

通过在 `uchar.h` 中定义的函数以及 ICU4J 的 `UCharacter` 类（参见 API 参考）以及 `UnicodeSet` ，ICU 提供了一种独立于区域设置的方式访问对所有 [Unicode 属性](../strings/properties)（除了 Unihan.txt 属性）以及 POSIX 字符类别。POSIX 字符类别是根据 UTS #18 中的建议实现的。

Unicode 字符数据库定义了 70 多个字符属性，它们是为大型字符集以及文本处理而设计的，并且随 Unicode 版本的更新而更新。Unicode 字符数据库可以简单地在线获取，这使得 Unicode 属性在各行各业实现一致性。

## 格式化和解析

### 货币格式化

#### POSIX

`strfmon()` 函数用于货币格式化。默认格式和货币显示符号或显示名称由区域设置 ID LC_MONETARY 选择。数字格式也可以通过类似于`printf()`使用的格式化字符串来控制。

#### 存在的问题

1. 通过区域设置 ID 选择货币是不可靠的：国家可能会改变货币，并且某些国家或地区的区域设置数据可能不可用，这会导致使用错误的货币。
2. 为格式化使用单一的区域设置 ID 使得用一种格式化方式格式化多种货币变得困难（例如，用于汇率列表或显示针对多种货币调整的商品价格）。 `strfmon()` 允许完全由用户指定数字格式化方式，但应用程序不能使用国家或地区的默认的数字格式化方式。
3. 可格式化的货币的集合被限制在特定的区域设置 ID。
4. 似乎没有解析货币值的函数。

#### ICU

ICU 数字格式 API 对数字格式化和货币（通过 ISO 代码指定）具有单独的正交设置（可以使用区域设置 ID 进行选择）。有关详细信息，请参阅 [格式化数字](../format/numbers/) 章节。
